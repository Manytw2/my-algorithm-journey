#include "utility.h"
#include <vector>
#include <iostream>

using namespace std;
using namespace algo;

/*
 * =====================================================================
 * 2023年408考研真题 - 第42题 (15分)
 * =====================================================================
 *
 * 📋 题目描述：
 * 给定一个长度为 n (1 ≤ n ≤ 10^5) 的升序排序数组 A[0...n-1] 和 q (1 ≤ q ≤ 10^5) 个查询。
 *
 * 🎯 任务：
 * 对于每个查询，给定一个整数 x，需要在数组 A 中找到 x 的最后一个出现位置。
 * 如果 x 不存在于 A 中，则返回 -1。
 *
 * ⚖️ 限制条件：
 * 1. 算法必须基于分治思想
 * 2. 预处理时间不超过 O(n)
 * 3. 单次查询时间不超过 O(log n)
 *
 * 📝 题目分点 (共15分)：
 *
 * 1️⃣ (4分) 请描述你的分治策略（用文字说明）
 *
 *    【在这里用文字描述你的分治策略】
 *
 *
 * 2️⃣ (6分) 请给出算法的伪代码
 *
 *    【在这里写你的伪代码】
 *
 *
 * 3️⃣ (3分) 证明单次查询的时间复杂度为 O(log n)
 *
 *    【在这里证明时间复杂度】
 *
 *
 * 4️⃣ (2分) 如果要求改为查找第一个出现位置，应该如何修改算法？
 *
 *    【在这里说明修改方案】
 *
 *
 * 🔍 提示：
 * - 可以利用二分查找的思想进行分治
 * - 注意处理边界情况（找到 x 后需要继续检查右边是否有相同的元素）
 * - 思考如何递归地缩小搜索范围
 *
 * =====================================================================
 */

// TODO: 在这里实现你的分治算法
int findLastOccurrence([[maybe_unused]] const vector<int>& A, [[maybe_unused]] int x) {
    // 你的算法实现

    return -1; // 未找到返回 -1
}

int main() {
    printAlgorithmTitle("查找最后一个出现位置 - 分治法（2023年408考研真题）");

    // 测试数据
    vector<int> arr = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5};

    cout << "📊 原始数组: ";
    array_utils::print(arr);

    // 测试用例
    vector<int> queries = {1, 2, 3, 5, 0, 6};

    cout << "\n🔍 查询测试：" << endl;
    for (int x : queries) {
        int pos = findLastOccurrence(arr, x);
        cout << "   查找 " << x << ": ";
        if (pos != -1) {
            cout << "位置 " << pos << " (值: " << arr[pos] << ")";
        } else {
            cout << "未找到";
        }
        cout << endl;
    }

    // 预期输出示例：
    // 查找 1: 位置 1 (值: 1)
    // 查找 2: 位置 4 (值: 2)
    // 查找 3: 位置 6 (值: 3)
    // 查找 5: 位置 11 (值: 5)
    // 查找 0: 未找到
    // 查找 6: 未找到

    cout << "\n📚 算法要求：" << endl;
    cout << "   时间复杂性: 单次查询 O(log n)" << endl;
    cout << "   空间复杂性: O(1) 辅助空间" << endl;
    cout << "   思想: 分治法 + 二分查找" << endl;

    return 0;
}

